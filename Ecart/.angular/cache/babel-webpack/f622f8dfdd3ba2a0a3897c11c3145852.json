{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Injectable, TemplateRef, Component, ViewEncapsulation, ContentChild, Input, NgModule } from '@angular/core';\nimport * as i1 from '@angular/router';\nimport { GuardsCheckEnd, RouterModule } from '@angular/router';\nimport { filter, map } from 'rxjs/operators';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/**\n * This directive is used to customize the breadcrumb label behavior\n * *xngBreadcrumbItem directive can be used in the child element of xng-breadcrumb\n * Usage: refer to the demo - app.component.html\n */\n\nfunction BreadcrumbComponent_ng_container_2_a_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_a_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const breadcrumb_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(breadcrumb_r1.label);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    \"xng-breadcrumb-link-disabled\": a0\n  };\n};\n\nconst _c1 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    $implicit: a0,\n    info: a1,\n    last: a2,\n    first: a3,\n    index: a4,\n    count: a5\n  };\n};\n\nfunction BreadcrumbComponent_ng_container_2_a_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"a\", 7);\n    i0.ɵɵtemplate(1, BreadcrumbComponent_ng_container_2_a_2_ng_container_1_Template, 1, 0, \"ng-container\", 8);\n    i0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_a_2_ng_container_2_Template, 2, 1, \"ng-container\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = i0.ɵɵnextContext();\n    const breadcrumb_r1 = ctx_r12.$implicit;\n    const isLast_r2 = ctx_r12.last;\n    const isFirst_r3 = ctx_r12.first;\n    const index_r4 = ctx_r12.index;\n    const count_r5 = ctx_r12.count;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(10, _c0, breadcrumb_r1.disable))(\"routerLink\", breadcrumb_r1.routeInterceptor ? breadcrumb_r1.routeInterceptor(breadcrumb_r1.routeLink, breadcrumb_r1) : breadcrumb_r1.routeLink)(\"queryParams\", ctx_r6.preserveQueryParams ? breadcrumb_r1.queryParams : undefined)(\"fragment\", ctx_r6.preserveFragment ? breadcrumb_r1.fragment : undefined)(\"target\", ctx_r6.anchorTarget ? ctx_r6.anchorTarget : \"_self\");\n    i0.ɵɵattribute(\"aria-disabled\", breadcrumb_r1.disable)(\"tabIndex\", breadcrumb_r1.disable ? -1 : 0);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r6.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction6(12, _c1, breadcrumb_r1.label, breadcrumb_r1.info, isLast_r2, isFirst_r3, index_r4, count_r5));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.itemTemplate);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_label_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_label_3_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const breadcrumb_r1 = i0.ɵɵnextContext(2).$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(breadcrumb_r1.label);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_label_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"label\", 10);\n    i0.ɵɵtemplate(1, BreadcrumbComponent_ng_container_2_label_3_ng_container_1_Template, 1, 0, \"ng-container\", 8);\n    i0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_label_3_ng_container_2_Template, 2, 1, \"ng-container\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = i0.ɵɵnextContext();\n    const breadcrumb_r1 = ctx_r16.$implicit;\n    const isLast_r2 = ctx_r16.last;\n    const isFirst_r3 = ctx_r16.first;\n    const index_r4 = ctx_r16.index;\n    const count_r5 = ctx_r16.count;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r7.itemTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction6(3, _c1, breadcrumb_r1.label, breadcrumb_r1.info, isLast_r2, isFirst_r3, index_r4, count_r5));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.itemTemplate);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_li_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_li_4_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r18.separator);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_li_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 11);\n    i0.ɵɵtemplate(1, BreadcrumbComponent_ng_container_2_li_4_ng_container_1_Template, 1, 0, \"ng-container\", 12);\n    i0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_li_4_ng_container_2_Template, 2, 1, \"ng-container\", 9);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r8.separatorTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r8.separatorTemplate);\n  }\n}\n\nfunction BreadcrumbComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"li\", 3);\n    i0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_a_2_Template, 3, 19, \"a\", 4);\n    i0.ɵɵtemplate(3, BreadcrumbComponent_ng_container_2_label_3_Template, 3, 10, \"label\", 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, BreadcrumbComponent_ng_container_2_li_4_Template, 3, 2, \"li\", 6);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const isLast_r2 = ctx.last;\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", !isLast_r2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", isLast_r2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !isLast_r2);\n  }\n}\n\nlet BreadcrumbItemDirective = /*#__PURE__*/(() => {\n  class BreadcrumbItemDirective {}\n\n  BreadcrumbItemDirective.ɵfac = function BreadcrumbItemDirective_Factory(t) {\n    return new (t || BreadcrumbItemDirective)();\n  };\n\n  BreadcrumbItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BreadcrumbItemDirective,\n    selectors: [[\"\", \"xngBreadcrumbItem\", \"\"]]\n  });\n  return BreadcrumbItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst PATH_PARAM = {\n  PREFIX: ':',\n  REGEX_IDENTIFIER: '/:[^/]+',\n  REGEX_REPLACER: '/[^/]+'\n};\nconst ALIAS_PREFIX = '@';\n\nconst isNonEmpty = obj => {\n  return obj && Object.keys(obj).length > 0;\n};\n\nlet BreadcrumbService = /*#__PURE__*/(() => {\n  class BreadcrumbService {\n    constructor(activatedRoute, router) {\n      this.activatedRoute = activatedRoute;\n      this.router = router;\n      this.baseHref = '/';\n      /**\n       * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.\n       * Breadcrumbs can be set from anywhere (component, service) in the app.\n       * On every breadcrumb update check this store and use the info if available.\n       */\n\n      this.dynamicBreadcrumbStore = [];\n      /**\n       * breadcrumbList for the current route\n       * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected\n       * If effected, update the change and emit a new stream\n       */\n\n      this.currentBreadcrumbs = [];\n      this.previousBreadcrumbs = [];\n      /**\n       * Breadcrumbs observable to be subscribed by BreadcrumbComponent\n       * Emits on every route change OR dynamic update of breadcrumb\n       */\n\n      this.breadcrumbs = new BehaviorSubject([]);\n      this.breadcrumbs$ = this.breadcrumbs.asObservable();\n      this.detectRouteChanges();\n    }\n    /**\n     * Whenever route changes build breadcrumb list again\n     */\n\n\n    detectRouteChanges() {\n      // Special case where breadcrumb service & component instantiates after a route is navigated.\n      // Ex: put breadcrumbs within *ngIf and this.router.events would be empty\n      // This check is also required where  { initialNavigation: 'enabledBlocking' } is applied to routes\n      this.setupBreadcrumbs(this.activatedRoute.snapshot);\n      this.router.events.pipe(filter(event => event instanceof GuardsCheckEnd)).subscribe(event => {\n        // activatedRoute doesn't carry data when shouldReuseRoute returns false\n        // use the event data with GuardsCheckEnd as workaround\n        // Check for shouldActivate in case where the authGuard returns false the breadcrumbs shouldn't be changed\n        if (event instanceof GuardsCheckEnd && event.shouldActivate) {\n          this.setupBreadcrumbs(event.state.root);\n        }\n      });\n    }\n\n    setupBreadcrumbs(activatedRouteSnapshot) {\n      this.previousBreadcrumbs = this.currentBreadcrumbs; // breadcrumb label for base OR root path. Usually, this can be set as 'Home'\n\n      const rootBreadcrumb = this.getRootBreadcrumb();\n      this.currentBreadcrumbs = rootBreadcrumb ? [rootBreadcrumb] : [];\n      this.prepareBreadcrumbList(activatedRouteSnapshot, this.baseHref);\n    }\n\n    getRootBreadcrumb() {\n      const rootConfig = this.router.config.find(config => config.path === '');\n      const rootBreadcrumb = this.extractObject(rootConfig?.data?.breadcrumb);\n      const storeItem = this.getFromStore(rootBreadcrumb.alias, '/');\n\n      if (isNonEmpty(rootBreadcrumb) || isNonEmpty(storeItem)) {\n        return { ...storeItem,\n          ...rootBreadcrumb,\n          routeLink: this.baseHref,\n          ...this.getQueryParamsFromPreviousList('/')\n        };\n      }\n    }\n\n    prepareBreadcrumbItem(activatedRouteSnapshot, routeLinkPrefix) {\n      const {\n        path,\n        breadcrumb\n      } = this.parseRouteData(activatedRouteSnapshot.routeConfig);\n      const resolvedSegment = this.resolvePathSegment(path, activatedRouteSnapshot);\n      const routeLink = `${routeLinkPrefix}${resolvedSegment}`;\n      const storeItem = this.getFromStore(breadcrumb.alias, routeLink);\n      const label = this.extractLabel(storeItem?.label || breadcrumb?.label, resolvedSegment);\n      let isAutoGeneratedLabel = false;\n      let autoGeneratedLabel = '';\n\n      if (!label) {\n        isAutoGeneratedLabel = true;\n        autoGeneratedLabel = resolvedSegment;\n      }\n\n      return { ...storeItem,\n        ...breadcrumb,\n        label: isAutoGeneratedLabel ? autoGeneratedLabel : label,\n        routeLink,\n        isAutoGeneratedLabel,\n        ...this.getQueryParamsFromPreviousList(routeLink)\n      };\n    }\n\n    prepareBreadcrumbList(activatedRouteSnapshot, routeLinkPrefix) {\n      if (activatedRouteSnapshot.routeConfig?.path) {\n        const breadcrumbItem = this.prepareBreadcrumbItem(activatedRouteSnapshot, routeLinkPrefix);\n        this.currentBreadcrumbs.push(breadcrumbItem);\n\n        if (activatedRouteSnapshot.firstChild) {\n          return this.prepareBreadcrumbList(activatedRouteSnapshot.firstChild, breadcrumbItem.routeLink + '/');\n        }\n      } else if (activatedRouteSnapshot.firstChild) {\n        return this.prepareBreadcrumbList(activatedRouteSnapshot.firstChild, routeLinkPrefix);\n      }\n\n      const lastCrumb = this.currentBreadcrumbs[this.currentBreadcrumbs.length - 1];\n      this.setQueryParamsForActiveBreadcrumb(lastCrumb, activatedRouteSnapshot); // remove breadcrumb items that needs to be hidden\n\n      const breadcrumbsToShow = this.currentBreadcrumbs.filter(item => !item.skip);\n      this.breadcrumbs.next(breadcrumbsToShow);\n    }\n\n    getFromStore(alias, routeLink) {\n      return this.dynamicBreadcrumbStore.find(item => {\n        return alias && alias === item.alias || routeLink && routeLink === item.routeLink || this.matchRegex(routeLink, item.routeRegex);\n      });\n    }\n    /**\n     * use exact match instead of regexp.test\n     * for /mentor/[^/]+ we should match '/mentor/12' but not '/mentor/12/abc'\n     */\n\n\n    matchRegex(routeLink, routeRegex) {\n      const match = routeLink.match(new RegExp(routeRegex));\n      return match?.[0] === routeLink;\n    }\n    /**\n     * if the path segment has route params, read the param value from url\n     * for each segment of route this gets called\n     *\n     * for mentor/:id/view - it gets called with mentor, :id, view 3 times\n     */\n\n\n    resolvePathSegment(segment, activatedRouteSnapshot) {\n      //quirk -segment can be defined as view/:id in route config in which case you need to make it view/<resolved-param>\n      if (segment.includes(PATH_PARAM.PREFIX)) {\n        Object.entries(activatedRouteSnapshot.params).forEach(([key, value]) => {\n          segment = segment.replace(`:${key}`, `${value}`);\n        });\n      }\n\n      return segment;\n    }\n    /**\n     * queryParams & fragments for previous breadcrumb path are copied over to new list\n     */\n\n\n    getQueryParamsFromPreviousList(routeLink) {\n      const {\n        queryParams,\n        fragment\n      } = this.previousBreadcrumbs.find(item => item.routeLink === routeLink) || {};\n      return {\n        queryParams,\n        fragment\n      };\n    }\n    /**\n     * set current activated route query params to the last breadcrumb item\n     */\n\n\n    setQueryParamsForActiveBreadcrumb(lastItem, activatedRouteSnapshot) {\n      if (lastItem) {\n        const {\n          queryParams,\n          fragment\n        } = activatedRouteSnapshot;\n        lastItem.queryParams = queryParams ? { ...queryParams\n        } : undefined;\n        lastItem.fragment = fragment;\n      }\n    }\n    /**\n     * For a specific route, breadcrumb can be defined either on parent OR it's child(which has empty path)\n     * When both are defined, child takes precedence\n     *\n     * Ex: Below we are setting breadcrumb on both parent and child.\n     * So, child takes precedence and \"Defined On Child\" is displayed for the route 'home'\n     * { path: 'home', loadChildren: () => import('./home/home.module').then((m) => m.HomeModule) , data: {breadcrumb: \"Defined On Module\"}}\n     *                                                AND\n     * children: [\n     *   { path: '', component: ShowUserComponent, data: {breadcrumb: \"Defined On Child\" }\n     * ]\n     */\n\n\n    parseRouteData(routeConfig) {\n      const {\n        path,\n        data\n      } = routeConfig;\n      const breadcrumb = this.mergeWithBaseChildData(routeConfig, data?.breadcrumb);\n      return {\n        path,\n        breadcrumb\n      };\n    }\n    /**\n     * get empty children of a module or Component. Empty child is the one with path: ''\n     * When parent and it's children (that has empty route path) define data merge them both with child taking precedence\n     */\n\n\n    mergeWithBaseChildData(routeConfig, config) {\n      if (!routeConfig) {\n        return this.extractObject(config);\n      }\n\n      let baseChild;\n\n      if (routeConfig.loadChildren) {\n        // To handle a module with empty child route\n        baseChild = routeConfig._loadedConfig.routes.find(route => route.path === '');\n      } else if (routeConfig.children) {\n        // To handle a component with empty child route\n        baseChild = routeConfig.children.find(route => route.path === '');\n      }\n\n      const childConfig = baseChild?.data?.breadcrumb;\n      return childConfig ? this.mergeWithBaseChildData(baseChild, { ...this.extractObject(config),\n        ...this.extractObject(childConfig)\n      }) : this.extractObject(config);\n    }\n    /**\n     * Update breadcrumb dynamically\n     *\n     * key can be a path | alias\n     *\n     * 1) Using complete route path. route can be passed the same way you define angular routes\n     * - path can be passed as 'exact path(routeLink)' or 'path with params(routeRegex)'\n     * - update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')\n     * - change visibility Ex: set('/mentor/:id/edit', { skip: true })\n     * ------------------------------------------ OR ------------------------------------------\n     * 2) Using route alias (prefixed with '@'). alias should be unique for a route\n     * - update label Ex: set('@mentor', 'Enabler')\n     * - change visibility Ex: set('@mentorEdit', { skip: true })\n     *\n     *\n     * value can be string | BreadcrumbObject | BreadcrumbFunction\n     */\n\n\n    set(key, breadcrumb) {\n      const breadcrumbObject = this.extractObject(breadcrumb);\n      let updateArgs;\n\n      if (key.startsWith(ALIAS_PREFIX)) {\n        updateArgs = ['alias', { ...breadcrumbObject,\n          alias: key.slice(1)\n        }];\n      } else if (key.includes(PATH_PARAM.PREFIX)) {\n        updateArgs = ['routeRegex', { ...breadcrumbObject,\n          routeRegex: this.buildRegex(key)\n        }];\n      } else {\n        updateArgs = ['routeLink', { ...breadcrumbObject,\n          routeLink: this.ensureLeadingSlash(key)\n        }];\n      } // For this route if previously a breadcrumb is not defined that sets isAutoGeneratedLabel: true\n      // change it to false since this is user supplied value\n\n\n      updateArgs[1].isAutoGeneratedLabel = false;\n      this.updateStore(...updateArgs);\n      this.updateCurrentBreadcrumbs(...updateArgs);\n    }\n    /**\n     * Update the store to reuse for dynamic declarations\n     * If the store already has this route definition update it, else add\n     */\n\n\n    updateStore(key, breadcrumb) {\n      const storeItemIndex = this.dynamicBreadcrumbStore.findIndex(item => {\n        return breadcrumb[key] === item[key];\n      });\n\n      if (storeItemIndex > -1) {\n        this.dynamicBreadcrumbStore[storeItemIndex] = { ...this.dynamicBreadcrumbStore[storeItemIndex],\n          ...breadcrumb\n        };\n      } else {\n        this.dynamicBreadcrumbStore.push({ ...breadcrumb\n        });\n      }\n    }\n    /**\n     * If breadcrumb is present in current breadcrumbs update it and emit new stream\n     */\n\n\n    updateCurrentBreadcrumbs(key, breadcrumb) {\n      const itemIndex = this.currentBreadcrumbs.findIndex(item => {\n        return key === 'routeRegex' ? this.matchRegex(item.routeLink, breadcrumb[key]) : breadcrumb[key] === item[key];\n      });\n\n      if (itemIndex > -1) {\n        this.currentBreadcrumbs[itemIndex] = { ...this.currentBreadcrumbs[itemIndex],\n          ...breadcrumb\n        };\n        const breadcrumbsToShow = this.currentBreadcrumbs.filter(item => !item.skip);\n        this.breadcrumbs.next([...breadcrumbsToShow]);\n      }\n    }\n    /**\n     * For a route with path param, we create regex dynamically from angular route syntax\n     * '/mentor/:id' becomes '/mentor/[^/]',\n     * breadcrumbService.set('/mentor/:id', 'Uday') should update 'Uday' as label for '/mentor/2' OR 'mentor/ada'\n     */\n\n\n    buildRegex(path) {\n      return this.ensureLeadingSlash(path).replace(new RegExp(PATH_PARAM.REGEX_IDENTIFIER, 'g'), PATH_PARAM.REGEX_REPLACER);\n    }\n\n    ensureLeadingSlash(path) {\n      return path.startsWith('/') ? path : `/${path}`;\n    }\n    /**\n     * In App's RouteConfig, breadcrumb can be defined as a string OR a function OR an object\n     *\n     * string: simple static breadcrumb label for a path\n     * function: callback that gets invoked with resolved path param\n     * object: additional data defined along with breadcrumb label that gets passed to *xngBreadcrumbItem directive\n     */\n\n\n    extractLabel(config, resolvedParam) {\n      const label = typeof config === 'object' ? config.label : config;\n\n      if (typeof label === 'function') {\n        return label(resolvedParam);\n      }\n\n      return label;\n    }\n\n    extractObject(config) {\n      // don't include {label} if config is undefined. This is important since we merge the configs\n      if (config && (typeof config === 'string' || typeof config === 'function')) {\n        return {\n          label: config\n        };\n      }\n\n      return config || {};\n    }\n\n  }\n\n  BreadcrumbService.ɵfac = function BreadcrumbService_Factory(t) {\n    return new (t || BreadcrumbService)(i0.ɵɵinject(i1.ActivatedRoute), i0.ɵɵinject(i1.Router));\n  };\n\n  BreadcrumbService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BreadcrumbService,\n    factory: BreadcrumbService.ɵfac,\n    providedIn: 'root'\n  });\n  return BreadcrumbService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BreadcrumbComponent = /*#__PURE__*/(() => {\n  class BreadcrumbComponent {\n    constructor(breadcrumbService, activateRoute) {\n      this.breadcrumbService = breadcrumbService;\n      this._separator = '/';\n      /**\n       * If true, breadcrumb is auto generated even without any mapping label\n       * Default label is same as route segment\n       */\n\n      this.autoGenerate = true;\n      /**\n       * By default query params will be preserved with breadcrumbs\n       */\n\n      this.preserveQueryParams = true;\n      /**\n       * By default query fragments will be preserved with breadcrumbs\n       */\n\n      this.preserveFragment = true;\n      /**\n       * custom class provided by consumer to increase specificity\n       * This will benefit to override styles that are conflicting\n       */\n\n      this.class = '';\n      this.setupMessage = 'not set up yet';\n      this.someParameterValue = null; // breadcrumb inside ngIf works only this way\n\n      activateRoute.params.subscribe(params => {\n        this.setupComponent(params['someParam']);\n      });\n    }\n    /**\n     * separator between breadcrumbs, defaults to '/'.\n     * User can customize separator either by passing a String or Template\n     *\n     * String --> Ex: <xng-breadcrumb separator=\"-\"> </xng-breadcrumb>\n     *\n     * Template --> Ex: <xng-breadcrumb [separator]=\"separatorTemplate\"> </xng-breadcrumb>\n     * <ng-template #separatorTemplate><mat-icon>arrow_right</mat-icon></ng-template>\n     */\n\n\n    set separator(value) {\n      if (value instanceof TemplateRef) {\n        this.separatorTemplate = value;\n        this._separator = undefined;\n      } else {\n        this.separatorTemplate = undefined;\n        this._separator = value || '/';\n      }\n    }\n\n    get separator() {\n      return this._separator;\n    }\n\n    setupComponent(someParam) {\n      this.setupMessage = 'set up at ' + new Date();\n      this.someParameterValue = someParam;\n    }\n\n    ngOnInit() {\n      this.breadcrumbs$ = this.breadcrumbService.breadcrumbs$.pipe(map(breadcrumbs => {\n        return breadcrumbs.filter(breadcrumb => {\n          // Usually, breadcrumb list can contain a combination of auto generated and user specified labels\n          // this filters autogenerated labels in case of \"[autoGenerate]: false\"\n          if (this.autoGenerate) {\n            return true;\n          }\n\n          return !breadcrumb.isAutoGeneratedLabel;\n        }).map(breadcrumb => {\n          // Do not mutate breadcrumb as its source of truth.\n          // There can be scenarios where we can have multiple xng-breadcrumb instances in page\n          const {\n            routeInterceptor,\n            routeLink\n          } = breadcrumb;\n          return { ...breadcrumb,\n            routeLink: routeInterceptor?.(routeLink, breadcrumb) || routeLink\n          };\n        });\n      }));\n    }\n\n  }\n\n  BreadcrumbComponent.ɵfac = function BreadcrumbComponent_Factory(t) {\n    return new (t || BreadcrumbComponent)(i0.ɵɵdirectiveInject(BreadcrumbService), i0.ɵɵdirectiveInject(i1.ActivatedRoute));\n  };\n\n  BreadcrumbComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: BreadcrumbComponent,\n    selectors: [[\"xng-breadcrumb\"]],\n    contentQueries: function BreadcrumbComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, BreadcrumbItemDirective, 5, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);\n      }\n    },\n    inputs: {\n      autoGenerate: \"autoGenerate\",\n      preserveQueryParams: \"preserveQueryParams\",\n      preserveFragment: \"preserveFragment\",\n      class: \"class\",\n      anchorTarget: \"anchorTarget\",\n      separator: \"separator\"\n    },\n    decls: 4,\n    vars: 4,\n    consts: [[\"aria-label\", \"breadcrumb\", 1, \"xng-breadcrumb-root\", 3, \"ngClass\"], [1, \"xng-breadcrumb-list\"], [4, \"ngFor\", \"ngForOf\"], [1, \"xng-breadcrumb-item\"], [\"class\", \"xng-breadcrumb-link\", \"role\", \"button\", \"rel\", \"noopener noreferrer\", 3, \"ngClass\", \"routerLink\", \"queryParams\", \"fragment\", \"target\", 4, \"ngIf\"], [\"class\", \"xng-breadcrumb-trail\", 4, \"ngIf\"], [\"class\", \"xng-breadcrumb-separator\", \"aria-hidden\", \"true\", \"role\", \"separator\", 4, \"ngIf\"], [\"role\", \"button\", \"rel\", \"noopener noreferrer\", 1, \"xng-breadcrumb-link\", 3, \"ngClass\", \"routerLink\", \"queryParams\", \"fragment\", \"target\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [4, \"ngIf\"], [1, \"xng-breadcrumb-trail\"], [\"aria-hidden\", \"true\", \"role\", \"separator\", 1, \"xng-breadcrumb-separator\"], [4, \"ngTemplateOutlet\"]],\n    template: function BreadcrumbComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"nav\", 0);\n        i0.ɵɵelementStart(1, \"ol\", 1);\n        i0.ɵɵtemplate(2, BreadcrumbComponent_ng_container_2_Template, 5, 3, \"ng-container\", 2);\n        i0.ɵɵpipe(3, \"async\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx.class);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(3, 2, ctx.breadcrumbs$));\n      }\n    },\n    directives: [i3.NgClass, i3.NgForOf, i3.NgIf, i1.RouterLinkWithHref, i3.NgTemplateOutlet],\n    pipes: [i3.AsyncPipe],\n    styles: [\".xng-breadcrumb-root{margin:0;color:#0009}.xng-breadcrumb-list{display:flex;align-items:center;flex-wrap:wrap;margin:0;padding:0}.xng-breadcrumb-item{list-style:none}.xng-breadcrumb-trail{display:flex;align-items:center;color:#000000e6}.xng-breadcrumb-link{display:flex;align-items:center;white-space:nowrap;color:inherit;text-decoration:none;transition:-webkit-text-decoration .3s;transition:text-decoration .3s;transition:text-decoration .3s,-webkit-text-decoration .3s;cursor:pointer}.xng-breadcrumb-link:hover{text-decoration:underline}.xng-breadcrumb-link-disabled{pointer-events:none;cursor:disabled}.xng-breadcrumb-separator{display:flex;-webkit-user-select:none;user-select:none;margin-left:8px;margin-right:8px}\\n\"],\n    encapsulation: 2\n  });\n  return BreadcrumbComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BreadcrumbModule = /*#__PURE__*/(() => {\n  class BreadcrumbModule {}\n\n  BreadcrumbModule.ɵfac = function BreadcrumbModule_Factory(t) {\n    return new (t || BreadcrumbModule)();\n  };\n\n  BreadcrumbModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BreadcrumbModule\n  });\n  BreadcrumbModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, RouterModule]]\n  });\n  return BreadcrumbModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of xng-breadcrumb\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BreadcrumbComponent, BreadcrumbItemDirective, BreadcrumbModule, BreadcrumbService }; //# sourceMappingURL=xng-breadcrumb.mjs.map","map":null,"metadata":{},"sourceType":"module"}